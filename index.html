<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Al√¥ Lilinha</title>
  <style>
    :root{
      --ui:#0b1220;
      --ui2:#0f172a;
      --txt:#e5e7eb;
      --txt2:#9ca3af;
      --accent:#f59e0b;
      --good:#22c55e;
      --bad:#ef4444;
      --shadow: rgba(0,0,0,.35);
    }
    html,body{height:100%;margin:0;background:#060812;color:var(--txt);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Arial;}
    #wrap{display:flex;align-items:center;justify-content:center;height:100%;padding:10px;box-sizing:border-box;}
    #game{
      width:min(1040px,100%);
      aspect-ratio: 16/9;
      background:#05070f;
      border-radius:18px;
      box-shadow: 0 18px 90px rgba(0,0,0,.55), 0 0 0 1px rgba(255,255,255,.06) inset;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      touch-action:none;
    }
    #overlay{
      position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
      background:
        radial-gradient(1000px 700px at 50% 35%, rgba(245,158,11,.10), transparent 65%),
        radial-gradient(900px 650px at 70% 65%, rgba(99,102,241,.10), transparent 65%),
        linear-gradient(180deg, rgba(0,0,0,.65), rgba(0,0,0,.72));
      padding:18px;box-sizing:border-box;
    }
    .card{
      width:min(820px,100%);
      background: linear-gradient(180deg, rgba(17,24,39,.92), rgba(2,6,23,.92));
      border:1px solid rgba(255,255,255,.10);
      border-radius:20px;
      box-shadow: 0 18px 90px rgba(0,0,0,.60);
      padding:18px 18px 16px;
      backdrop-filter: blur(10px);
    }
    .toprow{display:flex;gap:12px;align-items:flex-start;justify-content:space-between;flex-wrap:wrap;}
    .title{
      font-weight:900;letter-spacing:.6px;margin:0;
      font-size: clamp(26px, 3.2vw, 42px);
      text-shadow: 0 2px 0 rgba(0,0,0,.35);
    }
    .subtitle{
      margin:8px 0 0;color:var(--txt2);line-height:1.38;
      font-size: clamp(13px, 1.6vw, 15px);
      max-width: 58ch;
      white-space: pre-line;
    }
    .badge{
      display:inline-flex;align-items:center;gap:8px;
      padding:8px 10px;border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      color: var(--txt);
      font-weight:800;font-size:12px;
      user-select:none;
    }
    .badge b{color:var(--accent);}
    .grid{display:grid;grid-template-columns: 1.25fr .75fr;gap:14px;margin-top:14px;}
    @media (max-width: 720px){ .grid{grid-template-columns:1fr;gap:12px;} }
    .panel{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(2,6,23,.45);
      border-radius:16px;
      padding:12px;
    }
    .panel h3{margin:0 0 8px;font-size:14px;letter-spacing:.5px;color:#cbd5e1}
    .panel p{margin:0;color:var(--txt2);font-size:13px;line-height:1.45}
    .controls{display:flex;flex-wrap:wrap;gap:8px;margin-top:12px;}
    button{
      cursor:pointer;border:1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(245,158,11,.95), rgba(217,119,6,.95));
      color:#111827;font-weight:900;
      padding:11px 12px;border-radius:14px;
      box-shadow: 0 10px 26px rgba(245,158,11,.18);
      letter-spacing:.3px;
    }
    button.secondary{
      background: linear-gradient(180deg, rgba(30,41,59,.92), rgba(17,24,39,.92));
      color: var(--txt);
      box-shadow:none;
    }
    button:disabled{opacity:.55;cursor:not-allowed}
    button:active{transform: translateY(1px);}
    .tiny{font-size:12px;color:var(--txt2);margin-top:10px;line-height:1.35}
    .hr{height:1px;background:rgba(255,255,255,.08);margin:12px 0;}
    .row{display:flex;gap:10px;align-items:center;justify-content:space-between;flex-wrap:wrap;}
    .kbd{
      font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;
      display:inline-flex;align-items:center;justify-content:center;
      min-width: 22px;
      padding:2px 7px;border-radius:9px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      color:#e2e8f0;
      font-weight:900;
    }

    /* Touch UI */
    #touchUI{
      position:fixed;left:0;right:0;bottom:0;
      display:none;gap:12px;justify-content:space-between;
      padding: max(10px, env(safe-area-inset-bottom)) 12px 12px;
      pointer-events:none;
    }
    .touchGroup{display:flex;gap:10px;pointer-events:none;}
    .touchBtn{
      width:66px;height:66px;border-radius:18px;
      background: rgba(2,6,23,.55);
      border:1px solid rgba(255,255,255,.14);
      box-shadow: 0 10px 36px rgba(0,0,0,.40);
      display:flex;align-items:center;justify-content:center;
      color:#e5e7eb;font-weight:900;
      pointer-events:auto;
      user-select:none;-webkit-user-select:none;
      touch-action:none;
      backdrop-filter: blur(10px);
    }
    .touchBtn:active{transform: translateY(1px);}
    .touchBtn small{font-size:11px;color:#cbd5e1;opacity:.95}
    .touchBtn .big{font-size:20px;line-height:1}
    .touchBtn.wide{width:92px}
    .hint{
      position:fixed;top:10px;left:50%;transform:translateX(-50%);
      background: rgba(2,6,23,.60);
      border:1px solid rgba(255,255,255,.12);
      border-radius:999px;padding:7px 10px;
      color:#cbd5e1;font-weight:900;font-size:12px;
      display:none;
      backdrop-filter: blur(10px);
      pointer-events:none;
      box-shadow: 0 10px 26px rgba(0,0,0,.35);
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="960" height="540"></canvas>
  </div>

  <div id="overlay">
    <div class="card" id="menuCard">
      <div class="toprow">
        <div>
          <h1 class="title">Al√¥ Lilinha</h1>
          <p class="subtitle" id="menuSubtitle">
            Lili, a cachorra caramelo mais esperta do bairro, est√° fugindo da pris√£o
            pra voltar pra casa. Pegue a chave, fuja do port√£o e n√£o deixe os guardas
            aumentarem o alerta ‚Äî porque quando o alarme toca, a bagun√ßa come√ßa.
          </p>
        </div>
        <div class="badge" id="saveBadge">Progresso: <b>Novo</b></div>
      </div>

      <div class="grid">
        <div class="panel">
          <h3>Como jogar</h3>
          <p>
            <span class="kbd">A</span>/<span class="kbd">D</span> ou <span class="kbd">‚Üê</span>/<span class="kbd">‚Üí</span> andar ¬∑
            <span class="kbd">W</span>/<span class="kbd">‚Üë</span>/<span class="kbd">Espa√ßo</span> pular ¬∑
            <span class="kbd">Shift</span> correr ¬∑
            <span class="kbd">E</span> interagir ¬∑
            <span class="kbd">P</span> pausar
          </p>
          <div class="hr"></div>
          <p>
            Itens: <b style="color:#eab308">Chave</b> abre port√µes ¬∑
            <b style="color:#a3e635">Ossos</b> pontua√ß√£o ¬∑
            <b style="color:#fb7185">Petiscos</b> recuperam vida.
          </p>
        </div>
        <div class="panel">
          <h3>Objetivo</h3>
          <p id="menuObjective">
            Fase 1: Encontre a chave da cela, abra o port√£o e alcance a sa√≠da.
          </p>
          <div class="controls">
            <button id="btnPlay">Jogar</button>
            <button id="btnContinue" class="secondary">Continuar</button>
            <button id="btnReset" class="secondary">Reiniciar</button>
          </div>
          <div class="tiny">
            Dica: se um guarda te enxergar no cone de vis√£o, o <b>ALERTA</b> sobe e podem aparecer persegui√ß√µes.
          </div>
        </div>
      </div>

      <div class="row" style="margin-top:12px;">
        <div class="tiny">Canvas 2D ‚Ä¢ Pixel art gerada por c√≥digo ‚Ä¢ Sem imagens externas</div>
        <div class="tiny" id="buildInfo"></div>
      </div>
    </div>
  </div>

  <div class="hint" id="hint"></div>

  <div id="touchUI">
    <div class="touchGroup">
      <div class="touchBtn" id="tLeft"><div><div class="big">‚óÄ</div><small>esq</small></div></div>
      <div class="touchBtn" id="tRight"><div><div class="big">‚ñ∂</div><small>dir</small></div></div>
    </div>
    <div class="touchGroup">
      <div class="touchBtn wide" id="tInteract"><div><div class="big">E</div><small>usar</small></div></div>
      <div class="touchBtn" id="tJump"><div><div class="big">‚§í</div><small>pulo</small></div></div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  /******************************************************************
   * ENGINE
   ******************************************************************/
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d", { alpha: false });

  const BASE_W = 960, BASE_H = 540;
  canvas.width = BASE_W; canvas.height = BASE_H;

  const Keys = new Set();
  const Pressed = new Set();
  const gamepad = { left:false, right:false, jump:false, interact:false, run:false };

  const overlay = document.getElementById("overlay");
  const saveBadge = document.getElementById("saveBadge");
  const btnPlay = document.getElementById("btnPlay");
  const btnContinue = document.getElementById("btnContinue");
  const btnReset = document.getElementById("btnReset");
  const menuObjective = document.getElementById("menuObjective");
  const buildInfo = document.getElementById("buildInfo");
  const menuSubtitle = document.getElementById("menuSubtitle");
  const hintEl = document.getElementById("hint");
  const touchUI = document.getElementById("touchUI");

  buildInfo.textContent = "v1.1 ‚Ä¢ " + new Date().toLocaleDateString("pt-BR");

  const isTouch = () => (navigator.maxTouchPoints || 0) > 0 || "ontouchstart" in window;

  function showHint(text, ms=1400){
    hintEl.textContent = text;
    hintEl.style.display = "block";
    clearTimeout(showHint._t);
    showHint._t = setTimeout(()=> hintEl.style.display = "none", ms);
  }

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function lerp(a,b,t){ return a + (b-a)*t; }

  const audio = (() => {
    let ctxA = null;
    function beep(freq=440, dur=0.06, type="square", vol=0.05){
      try{
        if(!ctxA) ctxA = new (window.AudioContext || window.webkitAudioContext)();
        const o = ctxA.createOscillator();
        const g = ctxA.createGain();
        o.type = type;
        o.frequency.value = freq;
        g.gain.value = vol;
        o.connect(g); g.connect(ctxA.destination);
        o.start();
        o.stop(ctxA.currentTime + dur);
      }catch(e){}
    }
    return { beep };
  })();

  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    Keys.add(k);
    if(!e.repeat) Pressed.add(k);

    const block = ["arrowleft","arrowright","arrowup"," "];
    if(block.includes(e.key.toLowerCase()) || e.key === " " || e.key === "ArrowLeft" || e.key === "ArrowRight" || e.key === "ArrowUp"){
      e.preventDefault();
    }
  }, { passive:false });

  window.addEventListener("keyup", (e) => {
    Keys.delete(e.key.toLowerCase());
  });

  function down(k){ return Keys.has(k); }
  function pressed(k){ return Pressed.has(k); }
  function clearPressed(){ Pressed.clear(); gamepad.interact = false; }

  function bindTouchBtn(el, on){
    let active = false;
    const set = (v) => { active = v; on(v); };
    const start = (e)=>{ e.preventDefault(); set(true); };
    const end = (e)=>{ e.preventDefault(); set(false); };
    el.addEventListener("pointerdown", start);
    el.addEventListener("pointerup", end);
    el.addEventListener("pointercancel", end);
    el.addEventListener("pointerleave", end);
    return () => active;
  }

  if(isTouch()){
    touchUI.style.display = "flex";
    bindTouchBtn(document.getElementById("tLeft"), v => gamepad.left = v);
    bindTouchBtn(document.getElementById("tRight"), v => gamepad.right = v);
    bindTouchBtn(document.getElementById("tJump"), v => gamepad.jump = v);
    bindTouchBtn(document.getElementById("tInteract"), v => gamepad.interact = v);
    showHint("Controles touch ativados");
  }

  // Pixel helpers
  function pixRect(x,y,w,h,color){
    ctx.fillStyle = color;
    ctx.fillRect(x|0, y|0, w|0, h|0);
  }
  function pixText(text, x, y, size=12, color="#e5e7eb", align="left"){
    ctx.save();
    ctx.fillStyle = color;
    ctx.font = `${size}px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace`;
    ctx.textAlign = align;
    ctx.textBaseline = "top";
    ctx.fillText(text, x|0, y|0);
    ctx.restore();
  }
  function vignette(str=0.55){
    const g = ctx.createRadialGradient(BASE_W/2, BASE_H/2, 60, BASE_W/2, BASE_H/2, Math.max(BASE_W,BASE_H)*0.75);
    g.addColorStop(0, "rgba(0,0,0,0)");
    g.addColorStop(1, `rgba(0,0,0,${str})`);
    ctx.fillStyle = g;
    ctx.fillRect(0,0,BASE_W,BASE_H);
  }
  function hash2(x,y){
    // deterministic 0..1
    let n = (x*374761393 + y*668265263) ^ (x<<13);
    n = (n ^ (n>>17)) * 1274126177;
    n = n ^ (n>>16);
    return ((n>>>0) % 10000) / 10000;
  }

  /******************************************************************
   * GAME
   ******************************************************************/
  const TILE = 24;
  const GRAV = 1600;
  const MAX_FALL = 1200;

  // Tile ids
  const T = {
    EMPTY: 0,
    DIRT:  1,
    STONE: 2,
    BRICK: 3,
    METAL: 4,
    GRASS: 5,
    ROAD:  6,
    PIPE:  7,
    HOUSE: 8,
    DOOR:  9,
    SPIKE: 10,
    LASER: 11
  };

  function makeLevel1(){
    const w = 120, h = 22;
    const tiles = new Array(w*h).fill(T.EMPTY);
    const set = (x,y,v)=> { if(x>=0&&y>=0&&x<w&&y<h) tiles[y*w+x]=v; };
    const get = (x,y)=> (x<0||y<0||x>=w||y>=h) ? T.STONE : tiles[y*w+x];

    for(let x=0;x<w;x++){
      for(let y=h-4;y<h;y++){
        set(x,y, y===h-4 ? T.BRICK : T.STONE);
      }
    }

    for(let x=0;x<40;x++){
      for(let y=0;y<h-4;y++){
        if(y===0 || y===h-5 || x===0 || x===39) set(x,y,T.BRICK);
      }
    }

    for(let x=6;x<34;x++) set(x,12,T.BRICK);
    for(let x=12;x<28;x++) set(x,8,T.BRICK);

    for(let y=14;y<h-5;y++){
      set(5,y,T.BRICK);
      set(9,y,T.BRICK);
    }
    for(let x=5;x<=9;x++) set(x,14,T.BRICK);
    set(7,15,T.DOOR);

    for(let x=40;x<w;x++){
      set(x,h-4,T.METAL);
      if(x%7===0 && x>48 && x<78) set(x,h-5,T.SPIKE);
    }
    for(let x=62;x<78;x++) set(x,h-8,T.METAL);
    for(let x=78;x<92;x++) set(x,h-6,T.METAL);

    set(94,h-5,T.DOOR);
    set(94,h-6,T.DOOR);

    for(let x=44;x<54;x++) set(x,4,T.BRICK);
    for(let x=52;x<60;x++) set(x,7,T.BRICK);

    return {
      id: 1, name: "Pris√£o",
      w,h,tiles,
      spawn: { x: 7*TILE, y: 13*TILE },
      checkpoint: { x: 55*TILE, y: (h-7)*TILE },
      exit: { x: 112*TILE, y: (h-8)*TILE, w: 3*TILE, h: 5*TILE },
      objectives: [
        "Encontre a chave da cela!",
        "Abra o port√£o da pris√£o!",
        "Corra at√© a sa√≠da!"
      ],
      get, set,
      theme: "prison"
    };
  }

  function makeLevel2(){
    const w=130,h=22;
    const tiles = new Array(w*h).fill(T.EMPTY);
    const set=(x,y,v)=>{ if(x>=0&&y>=0&&x<w&&y<h) tiles[y*w+x]=v; };
    const get=(x,y)=> (x<0||y<0||x>=w||y>=h) ? T.STONE : tiles[y*w+x];

    for(let x=0;x<w;x++){
      for(let y=h-4;y<h;y++){
        set(x,y, y===h-4 ? (x<50?T.ROAD:T.PIPE) : T.STONE);
      }
    }

    for(let x=34;x<86;x++){
      set(x,h-5,T.PIPE);
      if(x%11===0) set(x,h-4,T.EMPTY);
    }

    for(let x=10;x<26;x++) set(x,12,T.METAL);
    for(let x=22;x<34;x++) set(x,9,T.METAL);
    for(let x=58;x<74;x++) set(x,11,T.METAL);
    for(let x=78;x<98;x++) set(x,8,T.METAL);
    for(let x=96;x<112;x++) set(x,12,T.METAL);

    for(let x=44;x<56;x++){
      set(x,14,T.METAL);
      if(x>=46 && x<=54) set(x,13,T.LASER);
    }

    for(let y=0;y<h-4;y++){
      set(0,y,T.STONE);
      set(w-1,y,T.STONE);
    }

    return {
      id: 2, name: "Ruas & Esgoto",
      w,h,tiles,
      spawn: { x: 4*TILE, y: 10*TILE },
      checkpoint: { x: 68*TILE, y: 9*TILE },
      exit: { x: 124*TILE, y: (h-9)*TILE, w: 4*TILE, h: 6*TILE },
      objectives: [
        "Atravesse o esgoto sem virar petisco de serra!",
        "Cuidado com lasers ‚Äî eles n√£o t√™m senso de humor.",
        "Siga em frente: o cheirinho de casa est√° perto!"
      ],
      get,set,
      theme: "sewer"
    };
  }

  function makeLevel3(){
    const w=140,h=22;
    const tiles = new Array(w*h).fill(T.EMPTY);
    const set=(x,y,v)=>{ if(x>=0&&y>=0&&x<w&&y<h) tiles[y*w+x]=v; };
    const get=(x,y)=> (x<0||y<0||x>=w||y>=h) ? T.STONE : tiles[y*w+x];

    for(let x=0;x<w;x++){
      const surface = (x<25) ? h-4 : (x<55) ? h-5 : (x<90) ? h-4 : (x<118) ? h-6 : h-4;
      for(let y=surface;y<h;y++){
        set(x,y, y===surface ? (x<90?T.GRASS:T.ROAD) : T.DIRT);
      }
    }

    for(let x=16;x<32;x++) set(x,12,T.DIRT);
    for(let x=32;x<44;x++) set(x,10,T.DIRT);
    for(let x=70;x<82;x++) set(x,11,T.DIRT);
    for(let x=96;x<110;x++) set(x,9,T.METAL);

    for(let x=125;x<138;x++){
      for(let y=6;y<14;y++){
        if(y===6||y===13||x===125||x===137) set(x,y,T.HOUSE);
      }
    }
    set(131,13,T.DOOR);

    for(let x=92;x<100;x++){
      if(x%2===0) set(x, (h-5), T.SPIKE);
    }

    return {
      id: 3, name: "Caminho de Casa",
      w,h,tiles,
      spawn: { x: 4*TILE, y: 10*TILE },
      checkpoint: { x: 86*TILE, y: 9*TILE },
      exit: { x: 129*TILE, y: 7*TILE, w: 6*TILE, h: 8*TILE },
      objectives: [
        "√öltima corrida! Evite as armadilhas e os curiosos.",
        "Se te perseguirem, faz cara de inocente. Funciona‚Ä¶ √†s vezes.",
        "Toque a porta de casa e grite (mentalmente): AL√î LILINHA!"
      ],
      get,set,
      theme: "neighborhood"
    };
  }

  const LEVELS = [makeLevel1, makeLevel2, makeLevel3];

  function aabb(ax,ay,aw,ah,bx,by,bw,bh){
    return ax<bx+bw && ax+aw>bx && ay<by+bh && ay+ah>by;
  }

  function newPlayer(){
    return {
      x: 0, y: 0, vx: 0, vy: 0,
      w: 18, h: 18,
      onGround:false,
      face: 1,
      run:false,
      jumpBuf: 0,
      coyote: 0,
      invuln: 0,
      hp: 5,
      maxHp: 5,
      bones: 0,
      treats: 0,
      hasKey: false,
      animT: 0,
      blink: 0,
      respawnX: 0, respawnY: 0,
      objectiveStep: 0,
      jumpHold: 0
    };
  }

  function newGuard(x,y,dir=1){
    return {
      kind:"guard",
      x,y, vx: 60*dir, vy: 0,
      w: 18, h: 20,
      patrolMin: x-5*TILE,
      patrolMax: x+5*TILE,
      face: dir,
      sawPlayer: 0,
      cooldown: 0
    };
  }

  function newDrone(x,y){
    return {
      kind:"drone",
      x,y, vx: 0, vy: 0,
      w: 18, h: 12,
      t: Math.random()*10,
      range: 4*TILE,
      baseY: y,
      laser: 0
    };
  }

  function newSaw(x,y){
    return {
      kind:"saw",
      x,y, w: 18, h: 18,
      t: Math.random()*10,
      range: 5*TILE,
      baseX: x
    };
  }

  function newChaser(x,y){
    return {
      kind:"chaser",
      x,y, vx: 0, vy: 0,
      w: 18, h: 18,
      ttl: 10,
      face: 1
    };
  }

  function newPickup(kind,x,y){
    return { kind, x,y, w: 14, h: 14, t: 0, taken:false };
  }

  function newDoor(x,y,locked=true, id="door"){
    return { kind:"door", x,y, w: TILE, h: TILE*2, locked, id, open:false };
  }

  // State
  const State = {
    mode: "menu",
    time: 0,
    dt: 0,
    camX: 0, camY: 0,
    shake: 0,
    alert: 0,
    alertDecay: 7,
    alertSpawned: false,
    levelIndex: 0,
    level: null,
    player: newPlayer(),
    entities: [],
    pickups: [],
    doors: [],
    msg: "",
    msgT: 0,
    particles: []
  };

  const SAVE_KEY = "aloLilinha_save_v1_1";

  function saveGame(){
    const s = {
      levelIndex: State.levelIndex,
      hp: State.player.hp,
      maxHp: State.player.maxHp,
      bones: State.player.bones,
      treats: State.player.treats,
      hasKey: State.player.hasKey,
      objectiveStep: State.player.objectiveStep,
      respawnX: State.player.respawnX,
      respawnY: State.player.respawnY,
      alert: State.alert,
    };
    localStorage.setItem(SAVE_KEY, JSON.stringify(s));
    updateSaveBadge();
  }

  function loadGame(){
    const raw = localStorage.getItem(SAVE_KEY);
    if(!raw) return null;
    try{ return JSON.parse(raw); }catch(e){ return null; }
  }

  function clearSave(){
    localStorage.removeItem(SAVE_KEY);
    updateSaveBadge();
  }

  function updateSaveBadge(){
    const s = loadGame();
    if(!s){
      saveBadge.innerHTML = `Progresso: <b>Novo</b>`;
      btnContinue.disabled = true;
    }else{
      saveBadge.innerHTML = `Progresso: <b>Fase ${s.levelIndex+1}</b>`;
      btnContinue.disabled = false;
    }
  }
  updateSaveBadge();

  function setMode(m){
    State.mode = m;
    overlay.style.display = (m==="menu") ? "flex" : "none";
  }

  function setMessage(text, t=1.8){
    State.msg = text;
    State.msgT = t;
  }

  function tileAt(L, wx, wy){
    const tx = Math.floor(wx / TILE);
    const ty = Math.floor(wy / TILE);
    if(tx<0||ty<0||tx>=L.w||ty>=L.h) return T.STONE;
    return L.tiles[ty*L.w+tx];
  }
  function solid(tile){
    return tile===T.DIRT||tile===T.STONE||tile===T.BRICK||tile===T.METAL||tile===T.GRASS||tile===T.ROAD||tile===T.PIPE||tile===T.HOUSE;
  }
  function hazard(tile){
    return tile===T.SPIKE || tile===T.LASER;
  }

  function doorBlocking(door){ return !door.open; }

  function moveAndCollide(L, ent, dt){
    let x = ent.x, y = ent.y;
    let vx = ent.vx, vy = ent.vy;

    // Horizontal
    x += vx*dt;

    for(const d of State.doors){
      if(doorBlocking(d) && aabb(x,y,ent.w,ent.h,d.x,d.y,d.w,d.h)){
        if(vx>0) x = d.x - ent.w;
        else if(vx<0) x = d.x + d.w;
        vx = 0;
      }
    }

    if(vx!==0){
      const dir = Math.sign(vx);
      const aheadX = dir>0 ? x+ent.w : x;
      const top = y+1;
      const bottom = y+ent.h-1;
      const y0 = Math.floor(top/TILE);
      const y1 = Math.floor(bottom/TILE);
      const tx = Math.floor(aheadX/TILE);
      for(let ty=y0;ty<=y1;ty++){
        const t = L.get(tx,ty);
        if(solid(t)){
          if(dir>0) x = tx*TILE - ent.w;
          else x = (tx+1)*TILE;
          vx = 0;
          break;
        }
      }
    }

    // Vertical
    y += vy*dt;
    ent.onGround = false;

    for(const d of State.doors){
      if(doorBlocking(d) && aabb(x,y,ent.w,ent.h,d.x,d.y,d.w,d.h)){
        if(vy>0){
          y = d.y - ent.h;
          vy = 0;
          ent.onGround = true;
        }else if(vy<0){
          y = d.y + d.h;
          vy = 0;
        }
      }
    }

    if(vy!==0){
      const dir = Math.sign(vy);
      const probeY = dir>0 ? y+ent.h : y;
      const left = x+2;
      const right = x+ent.w-2;
      const x0 = Math.floor(left/TILE);
      const x1 = Math.floor(right/TILE);
      const ty = Math.floor(probeY/TILE);
      for(let tx=x0;tx<=x1;tx++){
        const t = L.get(tx,ty);
        if(solid(t)){
          if(dir>0){
            y = ty*TILE - ent.h;
            vy = 0;
            ent.onGround = true;
          }else{
            y = (ty+1)*TILE;
            vy = 0;
          }
          break;
        }
      }
    }

    ent.x = x; ent.y = y; ent.vx = vx; ent.vy = vy;
  }

  function hurtPlayer(amount=1, knockX=220, knockY=-380){
    const p = State.player;
    if(p.invuln>0) return;
    p.hp -= amount;
    p.invuln = 1.0;
    p.vx = knockX * -p.face;
    p.vy = knockY;
    State.shake = 0.25;
    audio.beep(140,0.08,"square",0.05);
    spawnBurst(p.x+p.w/2, p.y+p.h/2, 10, "rgba(251,113,133,0.9)");
    if(p.hp<=0){
      State.mode = "gameover";
      setMode("menu");
      menuSubtitle.textContent =
        "Game Over. Lili tentou, mas levou um susto daqueles.\nBora tentar de novo ‚Äî agora com mais caramelo e menos problema?";
      btnPlay.textContent = "Tentar novamente";
      btnContinue.style.display = "none";
      menuObjective.textContent = "Dica: use checkpoints e observe cones de vis√£o.";
    }
  }

  function respawn(){
    const p = State.player;
    p.hp = p.maxHp;
    p.vx = 0; p.vy = 0;
    p.x = p.respawnX;
    p.y = p.respawnY;
    State.alert = Math.max(0, State.alert-20);
    State.alertSpawned = false;
    setMessage("Respawn no checkpoint. Lili: ‚Äút√° tudo sob controle‚Ä¶‚Äù");
    spawnBurst(p.x+p.w/2, p.y+p.h/2, 14, "rgba(56,189,248,0.7)");
  }

  function tryInteract(){
    const p = State.player;
    for(const d of State.doors){
      if(aabb(p.x-6,p.y-6,p.w+12,p.h+12, d.x,d.y,d.w,d.h)){
        if(!d.open){
          if(d.locked){
            if(p.hasKey){
              d.locked = false;
              d.open = true;
              p.hasKey = false;
              audio.beep(880,0.06,"square",0.05);
              audio.beep(660,0.06,"square",0.05);
              setMessage("Clique! Port√£o aberto. Lili: ‚Äúobrigada, chavezinha!‚Äù");
              spawnBurst(d.x+d.w/2, d.y+d.h/2, 10, "rgba(245,158,11,0.9)");
              if(State.level.id===1 && p.objectiveStep<2){
                p.objectiveStep = 2;
                setMessage(State.level.objectives[p.objectiveStep]);
              }
              saveGame();
              return;
            }else{
              audio.beep(220,0.06,"square",0.05);
              setMessage("T√° trancado. Precisa de uma chave.");
              return;
            }
          }else{
            d.open = true;
            audio.beep(740,0.06,"square",0.05);
            setMessage("Porta aberta!");
            saveGame();
            return;
          }
        }
      }
    }
  }

  function addAlert(v){
    State.alert = clamp(State.alert + v, 0, 100);
    if(State.alert >= 100 && !State.alertSpawned){
      const p = State.player;
      const spawnX = p.x - 220;
      const spawnY = p.y;
      State.entities.push(newChaser(spawnX, spawnY));
      State.alertSpawned = true;
      State.shake = 0.35;
      setMessage("ALERTA M√ÅXIMO! Eles soltaram um perseguidor! üò¨");
      audio.beep(120,0.12,"square",0.06);
      audio.beep(180,0.12,"square",0.06);
      audio.beep(220,0.12,"square",0.06);
      spawnBurst(p.x+p.w/2, p.y+p.h/2, 18, "rgba(239,68,68,0.85)");
    }
  }

  function nextLevel(){
    const idx = State.levelIndex + 1;
    if(idx >= LEVELS.length){
      State.mode = "win";
      setMode("menu");
      menuSubtitle.textContent =
        "Lili chegou em casa! üè°üê∂\n\nEla olha pra voc√™ e pensa: ‚ÄúAl√¥ Lilinha‚Ä¶ eu consegui!‚Äù\nDepois ela d√° uma voltinha, encontra um petisco imagin√°rio e decide que pris√£o mesmo √© ficar sem carinho.";
      btnPlay.textContent = "Jogar de novo";
      btnContinue.style.display = "none";
      menuObjective.textContent = "Fim! (Mas Lili ainda quer ossos.)";
      clearSave();
      return;
    }
    startLevel(idx, null);
    State.mode = "playing";
    setMode("playing");
    saveGame();
  }

  function togglePause(){
    if(State.mode==="playing"){
      State.mode="paused";
      setMode("menu");
      menuSubtitle.textContent = "Pausado. Lili aproveitou pra pensar em petiscos. (Prioridades.)";
      btnPlay.textContent = "Voltar";
      btnContinue.style.display = "none";
      menuObjective.textContent = "Pressione P para continuar.";
    }else if(State.mode==="paused"){
      State.mode="playing";
      setMode("playing");
      btnContinue.style.display = "";
      menuSubtitle.textContent =
        "Lili, a cachorra caramelo mais esperta do bairro, est√° fugindo da pris√£o pra voltar pra casa. Pegue a chave, fuja do port√£o e n√£o deixe os guardas aumentarem o alerta ‚Äî porque quando o alarme toca, a bagun√ßa come√ßa.";
      btnPlay.textContent = "Jogar";
    }
  }

  function startLevel(index, fromSave=null){
    State.levelIndex = clamp(index,0,LEVELS.length-1);
    State.level = LEVELS[State.levelIndex]();
    State.entities = [];
    State.pickups = [];
    State.doors = [];
    State.alert = 0;
    State.alertSpawned = false;
    State.time = 0;
    State.particles = [];

    const p = State.player = newPlayer();
    p.maxHp = 5; p.hp = 5;

    const L = State.level;

    // scan door tiles -> entities
    for(let y=0;y<L.h;y++){
      for(let x=0;x<L.w;x++){
        const id = L.tiles[y*L.w+x];
        if(id === T.DOOR){
          L.tiles[y*L.w+x] = T.EMPTY;
          const dy = (y*TILE - TILE);
          State.doors.push(newDoor(x*TILE, dy, true, `door_${x}_${y}`));
        }
      }
    }

    if(L.id===1){
      State.pickups.push(newPickup("key", 12*TILE, 7*TILE));
      State.pickups.push(newPickup("bone", 26*TILE, 7*TILE));
      State.pickups.push(newPickup("treat", 56*TILE, (L.h-9)*TILE));
      State.pickups.push(newPickup("checkpoint", L.checkpoint.x, L.checkpoint.y));
      State.entities.push(newGuard(20*TILE, (L.h-7)*TILE, 1));
      State.entities.push(newGuard(72*TILE, (L.h-7)*TILE, -1));
      State.entities.push(newDrone(52*TILE, 9*TILE));
      State.entities.push(newSaw(84*TILE, (L.h-7)*TILE));
    } else if(L.id===2){
      State.pickups.push(newPickup("bone", 18*TILE, 8*TILE));
      State.pickups.push(newPickup("treat", 60*TILE, 10*TILE));
      State.pickups.push(newPickup("bone", 94*TILE, 7*TILE));
      State.pickups.push(newPickup("checkpoint", L.checkpoint.x, L.checkpoint.y));
      State.entities.push(newGuard(28*TILE, (L.h-7)*TILE, 1));
      State.entities.push(newSaw(44*TILE, (L.h-7)*TILE));
      State.entities.push(newDrone(70*TILE, 7*TILE));
      State.entities.push(newDrone(102*TILE, 9*TILE));
    } else if(L.id===3){
      State.pickups.push(newPickup("treat", 24*TILE, 9*TILE));
      State.pickups.push(newPickup("bone", 40*TILE, 9*TILE));
      State.pickups.push(newPickup("bone", 76*TILE, 10*TILE));
      State.pickups.push(newPickup("checkpoint", L.checkpoint.x, L.checkpoint.y));
      State.entities.push(newGuard(58*TILE, (L.h-7)*TILE, 1));
      State.entities.push(newGuard(98*TILE, (L.h-8)*TILE, -1));
      State.entities.push(newDrone(110*TILE, 7*TILE));
      State.entities.push(newSaw(92*TILE, (L.h-7)*TILE));
    }

    // spawn
    p.x = L.spawn.x; p.y = L.spawn.y;
    p.respawnX = p.x; p.respawnY = p.y;
    p.objectiveStep = 0;

    // Apply save
    if(fromSave){
      State.levelIndex = clamp(fromSave.levelIndex ?? State.levelIndex,0,LEVELS.length-1);
      if(State.levelIndex !== index) return startLevel(State.levelIndex, fromSave);

      p.maxHp = fromSave.maxHp ?? p.maxHp;
      p.hp = clamp(fromSave.hp ?? p.hp, 1, p.maxHp);
      p.bones = fromSave.bones ?? 0;
      p.treats = fromSave.treats ?? 0;
      p.hasKey = !!fromSave.hasKey;
      p.objectiveStep = fromSave.objectiveStep ?? 0;
      p.x = fromSave.respawnX ?? p.x;
      p.y = fromSave.respawnY ?? p.y;
      p.respawnX = p.x; p.respawnY = p.y;
      State.alert = fromSave.alert ?? 0;

      for(const pk of State.pickups){
        if(pk.kind==="checkpoint" && Math.abs(pk.x - p.respawnX) < 6 && Math.abs(pk.y - (p.respawnY+20)) < 60){
          pk.taken = true;
        }
      }
    }

    menuObjective.textContent = `Fase ${L.id}: ${L.objectives[0]}`;
    setMessage(L.objectives[p.objectiveStep] || "Boa sorte!");
  }

  /******************************************************************
   * VISUALS: background + tiles + sprites + particles
   ******************************************************************/
  function drawBackground(theme, camX){
    // base gradients per theme
    if(theme==="prison"){
      const g = ctx.createLinearGradient(0,0,0,BASE_H);
      g.addColorStop(0,"#0a1022");
      g.addColorStop(0.55,"#060816");
      g.addColorStop(1,"#04050d");
      ctx.fillStyle = g; ctx.fillRect(0,0,BASE_W,BASE_H);

      // moving bars (parallax)
      for(let i=0;i<28;i++){
        const x = ((i*56 - camX*0.18 + (State.time*14)) % (BASE_W+120)) - 60;
        pixRect(x, 0, 10, BASE_H, "rgba(148,163,184,0.05)");
        pixRect(x+3, 0, 2, BASE_H, "rgba(0,0,0,0.10)");
      }

      // cold fog
      const f = ctx.createRadialGradient(BASE_W*0.35, BASE_H*0.55, 70, BASE_W*0.35, BASE_H*0.55, 560);
      f.addColorStop(0,"rgba(99,102,241,0.07)");
      f.addColorStop(1,"rgba(0,0,0,0)");
      ctx.fillStyle = f; ctx.fillRect(0,0,BASE_W,BASE_H);

    } else if(theme==="sewer"){
      const g = ctx.createLinearGradient(0,0,0,BASE_H);
      g.addColorStop(0,"#071c17");
      g.addColorStop(0.6,"#050a10");
      g.addColorStop(1,"#03040b");
      ctx.fillStyle = g; ctx.fillRect(0,0,BASE_W,BASE_H);

      // big pipe silhouettes
      for(let i=0;i<10;i++){
        const x = ((i*150 - camX*0.25) % (BASE_W+260)) - 140;
        pixRect(x, 110, 140, 34, "rgba(16,185,129,0.06)");
        pixRect(x+18, 58, 34, 90, "rgba(16,185,129,0.05)");
      }
      // slime glow
      const s = ctx.createRadialGradient(BASE_W*0.55, BASE_H*0.55, 60, BASE_W*0.55, BASE_H*0.55, 520);
      s.addColorStop(0,"rgba(34,197,94,0.08)");
      s.addColorStop(1,"rgba(0,0,0,0)");
      ctx.fillStyle = s; ctx.fillRect(0,0,BASE_W,BASE_H);

      // bubbles/dust
      for(let i=0;i<55;i++){
        const x = (i*97 + Math.floor(camX*0.12)) % (BASE_W+120) - 60;
        const y = (i*41 + Math.floor(State.time*40)) % (BASE_H+60) - 30;
        const a = 0.04 + (i%6)*0.01;
        pixRect(x, y, 2, 2, `rgba(255,255,255,${a})`);
      }

    } else {
      // neighborhood
      const g = ctx.createLinearGradient(0,0,0,BASE_H);
      g.addColorStop(0,"#0b1a3a");
      g.addColorStop(0.35,"#07112a");
      g.addColorStop(1,"#04050d");
      ctx.fillStyle = g; ctx.fillRect(0,0,BASE_W,BASE_H);

      // moon/sun glow
      const sun = ctx.createRadialGradient(BASE_W*0.22, BASE_H*0.22, 35, BASE_W*0.22, BASE_H*0.22, 420);
      sun.addColorStop(0,"rgba(56,189,248,0.18)");
      sun.addColorStop(0.35,"rgba(245,158,11,0.08)");
      sun.addColorStop(1,"rgba(0,0,0,0)");
      ctx.fillStyle = sun; ctx.fillRect(0,0,BASE_W,BASE_H);

      // clouds
      for(let i=0;i<10;i++){
        const x = ((i*190 - camX*0.14 + State.time*8) % (BASE_W+360)) - 180;
        const y = 60 + (i%4)*26;
        pixRect(x,y,130,20,"rgba(255,255,255,0.05)");
        pixRect(x+18,y-9,86,18,"rgba(255,255,255,0.04)");
        pixRect(x+46,y+12,70,14,"rgba(255,255,255,0.03)");
      }

      // stars
      for(let i=0;i<70;i++){
        const sx = (i*157 + Math.floor(camX*0.10)) % (BASE_W+200) - 100;
        const sy = (i*73) % BASE_H;
        const a = 0.12 + (i%6)*0.02;
        pixRect(sx, sy, 2, 2, `rgba(255,255,255,${a})`);
      }
    }
  }

  function drawTile(id, x, y, theme, tx, ty){
    const n = hash2(tx,ty);
    const n2 = hash2(tx+9,ty-7);

    const outline = "rgba(0,0,0,0.25)";
    const hi = "rgba(255,255,255,0.08)";

    if(id===T.DIRT){
      const base = n<0.5 ? "#4a2f1f" : "#402a1d";
      pixRect(x,y,TILE,TILE,base);
      pixRect(x,y+TILE-6,TILE,6,"#2d1c13");
      if(n2>0.6) pixRect(x+4,y+6,3,3,hi);
      if(n2<0.25) pixRect(x+13,y+12,6,3,outline);
    }
    else if(id===T.GRASS){
      pixRect(x,y,TILE,TILE,"#2f241a");
      const top = (n<0.33) ? "#1faa59" : "#169a4c";
      pixRect(x,y,TILE,7,top);
      // tufts
      if(n2>0.65){ pixRect(x+4,y+2,2,2,"rgba(255,255,255,0.10)"); pixRect(x+15,y+3,2,2,"rgba(0,0,0,0.16)"); }
    }
    else if(id===T.STONE){
      const base = (n<0.5) ? "#3f454e" : "#3a4048";
      pixRect(x,y,TILE,TILE,base);
      pixRect(x+2,y+3,6,3,hi);
      pixRect(x+12,y+11,6,4,"rgba(0,0,0,0.24)");
      if(n2>0.7) pixRect(x+8,y+15,4,2,hi);
    }
    else if(id===T.BRICK){
      const base = (n<0.5) ? "#6b2a2a" : "#612424";
      pixRect(x,y,TILE,TILE,base);
      // mortar lines
      pixRect(x,y+7,TILE,1,"rgba(0,0,0,0.22)");
      pixRect(x,y+14,TILE,1,"rgba(0,0,0,0.22)");
      // vertical mortar shifts
      const shift = (ty%2===0) ? 10 : 4;
      pixRect(x+shift,y,1,7,"rgba(0,0,0,0.18)");
      pixRect(x+(shift+8),y+7,1,TILE-7,"rgba(0,0,0,0.18)");
      // grime
      if(n2>0.62) pixRect(x+3,y+3,4,2,"rgba(255,255,255,0.07)");
      if(n2<0.22) pixRect(x+12,y+18,8,2,"rgba(0,0,0,0.25)");
    }
    else if(id===T.METAL){
      const base = (n<0.45) ? "#374151" : "#2f3947";
      pixRect(x,y,TILE,TILE,base);
      pixRect(x,y,TILE,3,"#4b5563");
      pixRect(x+3,y+6,TILE-6,1,"rgba(255,255,255,0.12)");
      pixRect(x+4,y+12,TILE-8,1,"rgba(0,0,0,0.25)");
      // rivets
      if((tx+ty)%3===0){
        pixRect(x+4,y+4,2,2,"rgba(255,255,255,0.10)");
        pixRect(x+TILE-6,y+TILE-6,2,2,"rgba(0,0,0,0.22)");
      }
    }
    else if(id===T.ROAD){
      const base = (n<0.5) ? "#1f2937" : "#1b2430";
      pixRect(x,y,TILE,TILE,base);
      pixRect(x+2,y+2,TILE-4,TILE-4,"rgba(255,255,255,0.03)");
      if(n2>0.75) pixRect(x+10,y+4,2,2,"rgba(255,255,255,0.08)");
    }
    else if(id===T.PIPE){
      pixRect(x,y,TILE,TILE,"#0b3a2b");
      pixRect(x+2,y+3,TILE-4,TILE-6,"#115e46");
      pixRect(x+4,y+6,TILE-8,2,"rgba(255,255,255,0.10)");
      if(n2<0.25) pixRect(x+6,y+14,TILE-12,2,"rgba(0,0,0,0.18)");
    }
    else if(id===T.HOUSE){
      pixRect(x,y,TILE,TILE,"#7c2d12");
      pixRect(x+2,y+2,TILE-4,TILE-4,"#9a3412");
      pixRect(x+4,y+4,4,4,"rgba(255,255,255,0.08)");
      if(n2>0.7) pixRect(x+12,y+10,7,2,"rgba(0,0,0,0.18)");
    }
    else if(id===T.LASER){
      // base tile (keep it non-solid) but show warning
      pixRect(x,y,TILE,TILE,"rgba(239,68,68,0.10)");
      pixRect(x+2,y+TILE-4,TILE-4,2,"rgba(239,68,68,0.45)");
      pixRect(x+4,y+4,TILE-8,2,"rgba(255,255,255,0.06)");
    }
    else if(id===T.SPIKE){
      pixRect(x,y,TILE,TILE,"rgba(255,255,255,0.02)");
      for(let i=0;i<3;i++){
        const sx = x + 3 + i*7;
        pixRect(sx, y+TILE-6, 4, 6, "#e5e7eb");
        pixRect(sx+1, y+TILE-6, 2, 2, "rgba(0,0,0,0.20)");
      }
    }
  }

  // Particles
  function spawnBurst(x,y,count,color){
    for(let i=0;i<count;i++){
      State.particles.push({
        x,y,
        vx: (Math.random()*2-1)*160,
        vy: (Math.random()*2-1)*180 - 60,
        life: 0.5 + Math.random()*0.35,
        t: 0,
        color
      });
    }
  }
  function updateParticles(dt){
    const L = State.level;
    for(const p of State.particles){
      p.t += dt;
      p.life -= dt;
      p.vy += 900*dt;
      p.x += p.vx*dt;
      p.y += p.vy*dt;
      // small friction
      p.vx *= Math.pow(0.01, dt);
      // bounce off ground tiles lightly
      if(L){
        const under = tileAt(L, p.x, p.y+2);
        if(solid(under) && p.vy>0){
          p.vy *= -0.35;
          p.vx *= 0.7;
        }
      }
    }
    State.particles = State.particles.filter(p=>p.life>0);
  }
  function renderParticles(camX,camY){
    for(const p of State.particles){
      const a = clamp(p.life/0.6,0,1);
      pixRect(p.x - camX, p.y - camY, 2, 2, p.color.replace(")", `,${a})`).replace("rgba(", "rgba("));
      // fallback if not rgba string with replacement:
      // we also draw a tiny glow
      ctx.save();
      ctx.globalAlpha = a*0.35;
      ctx.fillStyle = p.color.startsWith("rgba") ? p.color : "rgba(255,255,255,0.6)";
      ctx.fillRect((p.x - camX - 1)|0, (p.y - camY - 1)|0, 4, 4);
      ctx.restore();
    }
  }

  // Sprites
  function drawLili(p, screenX, screenY){
    const frame = Math.floor(p.animT*10) % 4;
    const flip = p.face < 0;
    const w = p.w, h = p.h;

    ctx.save();
    ctx.translate((screenX + w/2)|0, (screenY + h/2)|0);
    ctx.scale(flip ? -1 : 1, 1);
    ctx.translate((-w/2)|0, (-h/2)|0);

    const fur = "#d08c3f";
    const fur2 = "#b9722b";
    const fur3 = "#8a4f1b";
    const dark = "#0b1220";
    const shine = "rgba(255,255,255,0.10)";

    const wag = Math.sin(State.time*10) * 2;

    // shadow
    ctx.save();
    ctx.globalAlpha = 0.25;
    pixRect(3, h-2, 12, 2, "rgba(0,0,0,0.8)");
    ctx.restore();

    // body
    pixRect(2,7,14,8,fur);
    pixRect(3,8,12,6,fur2);

    // chest
    pixRect(6,10,4,4,fur);

    // head
    pixRect(10,3,8,7,fur);
    pixRect(11,4,6,5,fur2);

    // ear
    pixRect(10,2,3,3,fur3);

    // snout
    pixRect(16,6,3,3,fur);
    pixRect(17,7,2,2,fur2);

    // nose
    pixRect(18,7,1,1,dark);

    // eye + brow
    if(p.blink>0){
      pixRect(14,5,2,1,dark);
    }else{
      pixRect(14,5,1,1,dark);
      pixRect(15,5,1,1,"rgba(255,255,255,0.08)");
    }

    // highlight
    pixRect(12,4,2,1,shine);

    // collar
    pixRect(10,10,6,1,"#ef4444");
    pixRect(12,11,2,1,"#f59e0b");

    // legs (frame)
    const legY = 14;
    const leg1 = (frame===0||frame===2)?1:0;
    const leg2 = (frame===1||frame===3)?1:0;
    pixRect(5,legY,2,3,fur3);
    pixRect(7,legY+leg1,2,3,fur3);
    pixRect(11,legY+leg2,2,3,fur3);
    pixRect(13,legY,2,3,fur3);

    // tail
    pixRect(0,8,3,2,fur3);
    pixRect(0,7+((wag>0)?1:0),2,1,fur2);

    ctx.restore();
  }

  function drawGuard(g, sx, sy){
    const frame = Math.floor(State.time*6) % 2;
    const flip = g.face < 0;
    ctx.save();
    ctx.translate((sx+g.w/2)|0, (sy+g.h/2)|0);
    ctx.scale(flip?-1:1,1);
    ctx.translate((-g.w/2)|0, (-g.h/2)|0);

    pixRect(4,3,10,14,"#111827");
    pixRect(5,4,8,12,"#374151");
    pixRect(5,0,8,5,"#cbd5e1");
    pixRect(6,1,6,3,"#94a3b8");
    pixRect(7,2,4,1,"#0b1220");
    pixRect(5,16,3,4,"#0b1220");
    pixRect(10,16+frame,3,4,"#0b1220");
    pixRect(1,10,3,1,"#0b1220");
    pixRect(1,11,3,1,"#111827");
    // badge
    pixRect(12,8,2,2,"#f59e0b");

    ctx.restore();

    // vision cone (nicer)
    const coneLen = 150;
    const cx = sx + g.w/2;
    const cy = sy + 10;
    ctx.save();
    ctx.globalAlpha = 0.10 + g.sawPlayer*0.30;
    ctx.fillStyle = g.sawPlayer>0 ? "rgba(239,68,68,0.32)" : "rgba(56,189,248,0.22)";
    ctx.beginPath();
    ctx.moveTo(cx,cy);
    const dir = g.face;
    ctx.lineTo(cx + dir*coneLen, cy-42);
    ctx.lineTo(cx + dir*coneLen, cy+42);
    ctx.closePath();
    ctx.fill();
    // inner brighter
    ctx.globalAlpha *= 0.65;
    ctx.fillStyle = g.sawPlayer>0 ? "rgba(239,68,68,0.22)" : "rgba(56,189,248,0.14)";
    ctx.beginPath();
    ctx.moveTo(cx,cy);
    ctx.lineTo(cx + dir*(coneLen*0.7), cy-26);
    ctx.lineTo(cx + dir*(coneLen*0.7), cy+26);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function drawDrone(d, sx, sy){
    pixRect(sx,sy,d.w,d.h,"#4b5563");
    pixRect(sx+2,sy+2,d.w-4,d.h-4,"#0b1220");
    pixRect(sx+4,sy+4,3,3,"#22c55e");
    pixRect(sx+9,sy+4,3,3,"#22c55e");
    if((Math.floor(State.time*4)%2)===0) pixRect(sx+6,sy+1,6,1,"#f59e0b");

    const beam = 92 + Math.sin(d.t*3)*10;
    ctx.save();
    ctx.globalAlpha = 0.10 + d.laser*0.30;
    ctx.fillStyle = d.laser>0 ? "rgba(239,68,68,0.30)" : "rgba(34,197,94,0.20)";
    ctx.beginPath();
    ctx.moveTo(sx+d.w/2, sy+d.h);
    ctx.lineTo(sx-32, sy+d.h+beam);
    ctx.lineTo(sx+d.w+32, sy+d.h+beam);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function drawSaw(s, sx, sy){
    const t = State.time*6;
    pixRect(sx,sy,18,18,"#0b1220");
    pixRect(sx+1,sy+1,16,16,"#cbd5e1");
    pixRect(sx+4,sy+4,10,10,"#4b5563");

    const tooth = ((Math.floor(t)%4)+4)%4;
    const toothC = "#f8fafc";
    if(tooth===0) pixRect(sx+8,sy,2,3,toothC);
    if(tooth===1) pixRect(sx+15,sy+8,3,2,toothC);
    if(tooth===2) pixRect(sx+8,sy+15,2,3,toothC);
    if(tooth===3) pixRect(sx,sy+8,3,2,toothC);

    // tiny glow
    ctx.save();
    ctx.globalAlpha = 0.14;
    pixRect(sx-2,sy-2,22,22,"rgba(239,68,68,0.15)");
    ctx.restore();
  }

  function drawChaser(c, sx, sy){
    pixRect(sx,sy,c.w,c.h,"#0b1220");
    pixRect(sx+2,sy+2,c.w-4,c.h-4,"#ef4444");
    pixRect(sx+4,sy+4,3,3,"#0b1220");
    pixRect(sx+11,sy+4,3,3,"#0b1220");
    pixRect(sx+6,sy+10,6,2,"#0b1220");
    // glow
    ctx.save();
    ctx.globalAlpha = 0.16;
    pixRect(sx-3,sy-3,24,24,"rgba(239,68,68,0.20)");
    ctx.restore();
  }

  function drawPickup(pk, sx, sy){
    pk.t += State.dt;
    const bob = Math.sin(pk.t*4)*2;
    const x = sx, y = sy + bob;

    // soft glow behind
    ctx.save();
    ctx.globalAlpha = 0.18;
    const glowColor = pk.kind==="key" ? "rgba(245,158,11,0.35)"
                    : pk.kind==="bone" ? "rgba(163,230,53,0.30)"
                    : pk.kind==="treat" ? "rgba(251,113,133,0.30)"
                    : "rgba(56,189,248,0.25)";
    pixRect(x-3,y-3,20,20,glowColor);
    ctx.restore();

    if(pk.kind==="key"){
      pixRect(x+2,y+5,10,4,"#eab308");
      pixRect(x+10,y+3,3,3,"#eab308");
      pixRect(x+11,y+4,1,1,"#0b1220");
      pixRect(x+4,y+4,2,1,"rgba(255,255,255,0.25)");
    }else if(pk.kind==="bone"){
      pixRect(x+3,y+6,8,3,"#a3e635");
      pixRect(x+2,y+5,2,2,"#a3e635");
      pixRect(x+10,y+5,2,2,"#a3e635");
      pixRect(x+2,y+8,2,2,"#a3e635");
      pixRect(x+10,y+8,2,2,"#a3e635");
    }else if(pk.kind==="treat"){
      pixRect(x+4,y+5,6,6,"#fb7185");
      pixRect(x+5,y+6,4,4,"rgba(255,255,255,0.14)");
    }else if(pk.kind==="checkpoint"){
      pixRect(x+5,y+2,2,16,"#e2e8f0");
      pixRect(x+7,y+2,8,5,"#f59e0b");
      pixRect(x+7,y+7,8,3,"#d97706");
      pixRect(x+7,y+10,5,2,"rgba(255,255,255,0.10)");
    }
  }

  function drawDoor(d, sx, sy){
    // frame
    pixRect(sx,sy,d.w,d.h,"#0b1220");
    if(d.open){
      // open state: subtle outline
      ctx.save();
      ctx.globalAlpha = 0.35;
      pixRect(sx+2,sy+2,d.w-4,d.h-4,"rgba(34,197,94,0.08)");
      ctx.restore();
      return;
    }
    pixRect(sx+2,sy+2,d.w-4,d.h-4,"#1f2937");
    for(let i=0;i<4;i++){
      pixRect(sx+4+i*5, sy+4, 2, d.h-8, "rgba(148,163,184,0.38)");
      pixRect(sx+4+i*5, sy+4, 1, d.h-8, "rgba(0,0,0,0.18)");
    }
    if(d.locked){
      pixRect(sx+d.w-8, sy+8, 4, 6, "#eab308");
      pixRect(sx+d.w-7, sy+10, 2, 2, "#0b1220");
      // tiny sparkle
      if((Math.floor(State.time*6)%6)===0) pixRect(sx+d.w-9, sy+7, 2, 2, "rgba(255,255,255,0.20)");
    }
  }

  function drawHUD(){
    const p = State.player;

    // Panel
    ctx.save();
    ctx.globalAlpha = 0.90;
    pixRect(10,10, 348, 68, "rgba(2,6,23,0.62)");
    ctx.globalAlpha = 1;
    ctx.strokeStyle = "rgba(255,255,255,0.12)";
    ctx.strokeRect(10.5,10.5,348,68);

    // hearts
    let x = 18, y = 18;
    for(let i=0;i<p.maxHp;i++){
      const full = i < p.hp;
      const c = full ? "#fb7185" : "rgba(255,255,255,0.18)";
      pixRect(x+2,y+2,4,4,c);
      pixRect(x+8,y+2,4,4,c);
      pixRect(x+2,y+6,10,6,c);
      pixRect(x+4,y+12,6,3,c);
      if(full){
        pixRect(x+4,y+5,2,1,"rgba(255,255,255,0.14)");
      }
      x += 18;
    }

    // items (keep emoji for clarity)
    pixText(`ü¶¥ ${p.bones}`, 18, 44, 14, "#cbd5e1");
    pixText(`üç™ ${p.treats}`, 108, 44, 14, "#cbd5e1");
    pixText(`üîë ${p.hasKey ? "1" : "0"}`, 204, 44, 14, "#cbd5e1");

    // alert bar
    const barX=268, barY=46, barW=80, barH=10;
    pixRect(barX,barY,barW,barH,"rgba(255,255,255,0.12)");
    const fillW = Math.floor(barW*(State.alert/100));
    pixRect(barX,barY, fillW, barH, State.alert>=70 ? "#ef4444" : "#38bdf8");
    pixText("ALERTA", barX, barY-14, 11, "#cbd5e1");
    ctx.restore();

    // objective banner
    const obj = State.level?.objectives?.[p.objectiveStep] || "";
    if(obj){
      ctx.save();
      ctx.globalAlpha = 0.95;
      const w = Math.min(720, 20 + obj.length*7);
      const bx = (BASE_W/2 - w/2)|0;
      pixRect(bx, 12, w, 22, "rgba(2,6,23,0.62)");
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.strokeRect(bx+0.5, 12.5, w, 22);
      pixText(obj, BASE_W/2, 15, 12, "#e5e7eb", "center");
      ctx.restore();
    }

    // message
    if(State.msgT>0){
      ctx.save();
      ctx.globalAlpha = clamp(State.msgT/1.2, 0, 1);
      pixRect(10, BASE_H-48, 600, 32, "rgba(2,6,23,0.66)");
      ctx.strokeStyle = "rgba(255,255,255,0.10)";
      ctx.strokeRect(10.5, BASE_H-47.5, 600, 32);
      pixText(State.msg, 20, BASE_H-42, 13, "#e5e7eb");
      ctx.restore();
    }
  }

  /******************************************************************
   * GAME LOOP: update + render
   ******************************************************************/
  function update(dt){
    State.dt = dt;
    State.time += dt;

    if(!State.level) return;

    const L = State.level;
    const p = State.player;

    // blink + message
    if(Math.random()<0.012) p.blink = 0.12;
    p.blink = Math.max(0, p.blink - dt);
    State.msgT = Math.max(0, State.msgT - dt);

    // pause
    if(pressed("p")) togglePause();
    if(State.mode!=="playing") return;

    // input
    const left = down("a") || down("arrowleft") || gamepad.left;
    const right = down("d") || down("arrowright") || gamepad.right;
    const jumpPressed = pressed("w") || pressed("arrowup") || pressed(" ") || pressed("space") || gamepad.jump;
    const jumpHeld = down("w") || down("arrowup") || down(" ") || down("space") || gamepad.jump;
    const run = down("shift") || gamepad.run;
    const interact = pressed("e") || gamepad.interact;

    if(interact) tryInteract();

    p.run = run;
    const speed = run ? 220 : 150;

    // jump buffer + coyote
    if(jumpPressed) p.jumpBuf = 0.14;
    else p.jumpBuf = Math.max(0, p.jumpBuf - dt);

    if(p.onGround) p.coyote = 0.12;
    else p.coyote = Math.max(0, p.coyote - dt);

    // horizontal
    let targetVX = 0;
    if(left) targetVX -= speed;
    if(right) targetVX += speed;
    if(targetVX !== 0) p.face = Math.sign(targetVX);
    p.vx = lerp(p.vx, targetVX, 1 - Math.pow(0.0001, dt));

    // gravity
    p.vy = Math.min(MAX_FALL, p.vy + GRAV*dt);

    // jump
    if(p.jumpBuf>0 && p.coyote>0){
      p.vy = -720;              // <<< PULO MAIS ALTO (antes -520)
      p.jumpBuf = 0;
      p.coyote = 0;
      p.jumpHold = 0.14;        // segurar pra um pouquinho mais alto
      audio.beep(520,0.04,"square",0.04);
      spawnBurst(p.x+p.w/2, p.y+p.h, 8, "rgba(245,158,11,0.7)");
    }

    // variable jump: while holding, reduce gravity briefly
    if(jumpHeld && p.jumpHold>0 && p.vy < 0){
      p.vy -= GRAV*dt*0.55; // "anti-grav" curto
      p.jumpHold = Math.max(0, p.jumpHold - dt);
    }else{
      p.jumpHold = Math.max(0, p.jumpHold - dt);
    }

    moveAndCollide(L, p, dt);

    p.animT += dt * (Math.abs(p.vx)>5 ? 1.5 : 0.6);
    p.invuln = Math.max(0, p.invuln - dt);

    // hazards
    const feetX0 = p.x+3, feetX1 = p.x+p.w-3;
    const headY0 = p.y+2, footY = p.y+p.h-1;

    const checkPoints = [
      [feetX0, footY],[feetX1, footY],[p.x+p.w/2, footY],[p.x+p.w/2, headY0]
    ];
    for(const [wx,wy] of checkPoints){
      const t = tileAt(L, wx, wy);
      if(hazard(t)){
        hurtPlayer(1, 240, -420);
        setMessage(t===T.SPIKE ? "Ai! Espinho. Lili: ‚Äúquem colocou isso a√≠?!‚Äù" : "ZAP! Laser. Lili: ‚Äúisso n√£o √© carinho!‚Äù");
        break;
      }
    }

    // pickups
    for(const pk of State.pickups){
      if(pk.taken) continue;
      if(aabb(p.x,p.y,p.w,p.h, pk.x, pk.y, pk.w, pk.h)){
        pk.taken = true;
        if(pk.kind==="key"){
          p.hasKey = true;
          audio.beep(880,0.05,"square",0.05);
          setMessage("Voc√™ pegou uma chave! üîë");
          spawnBurst(pk.x, pk.y, 10, "rgba(245,158,11,0.9)");
          if(L.id===1 && p.objectiveStep<1){
            p.objectiveStep = 1;
            setMessage(L.objectives[p.objectiveStep]);
          }
        }else if(pk.kind==="bone"){
          p.bones += 1;
          audio.beep(660,0.03,"square",0.03);
          spawnBurst(pk.x, pk.y, 8, "rgba(163,230,53,0.75)");
        }else if(pk.kind==="treat"){
          p.treats += 1;
          p.hp = Math.min(p.maxHp, p.hp + 1);
          audio.beep(740,0.04,"square",0.04);
          setMessage("Petisco! Vida +1 üç™");
          spawnBurst(pk.x, pk.y, 10, "rgba(251,113,133,0.75)");
        }else if(pk.kind==="checkpoint"){
          p.respawnX = pk.x;
          p.respawnY = pk.y - 20;
          setMessage("Checkpoint ativado! ‚úÖ");
          audio.beep(520,0.05,"square",0.05);
          spawnBurst(pk.x, pk.y, 12, "rgba(56,189,248,0.8)");
          saveGame();
        }
      }
    }

    // doors auto-open if unlocked
    for(const d of State.doors){
      if(d.open) continue;
      if(!d.locked && aabb(p.x,p.y,p.w,p.h,d.x,d.y,d.w,d.h)){
        d.open = true;
      }
    }

    // entities
    for(const e of State.entities){
      if(e.kind==="guard"){
        e.cooldown = Math.max(0, e.cooldown - dt);

        e.vy = Math.min(MAX_FALL, e.vy + GRAV*dt);
        moveAndCollide(L, e, dt);

        if(e.x < e.patrolMin){ e.x = e.patrolMin; e.face = 1; e.vx = 60; }
        if(e.x > e.patrolMax){ e.x = e.patrolMax; e.face = -1; e.vx = -60; }
        if(Math.abs(e.vx) < 1){
          e.face *= -1;
          e.vx = 60*e.face;
        }

        const coneLen = 150;
        const cx = e.x + e.w/2;
        const cy = e.y + 10;
        const inFront = (e.face>0) ? (p.x > cx && p.x < cx+coneLen) : (p.x < cx && p.x > cx-coneLen);
        const dy = Math.abs((p.y + p.h/2) - cy);
        const visible = inFront && dy < 46;

        if(visible){
          e.sawPlayer = clamp(e.sawPlayer + dt*2.2, 0, 1);
          addAlert(dt*28);
          if(e.sawPlayer>0.7 && e.cooldown<=0){
            e.cooldown = 1.2;
            setMessage("Guarda: ‚ÄúEi! Volta aqui, caramelo!‚Äù");
            audio.beep(260,0.08,"square",0.05);
            addAlert(12);
          }
        }else{
          e.sawPlayer = Math.max(0, e.sawPlayer - dt*1.2);
        }

        if(aabb(p.x,p.y,p.w,p.h, e.x,e.y,e.w,e.h)){
          hurtPlayer(1, 260, -360);
          setMessage("O guarda te pegou! Lili: ‚Äúsem abra√ßo hoje.‚Äù");
        }
      }
      else if(e.kind==="drone"){
        e.t += dt;
        e.y = e.baseY + Math.sin(e.t*1.5)*10;
        const px = p.x + p.w/2, py = p.y + p.h/2;
        const dx = Math.abs(px - (e.x + e.w/2));
        const dy2 = py - (e.y + e.h);
        const sees = dx < 34 && dy2 > 0 && dy2 < 110;
        if(sees){
          e.laser = clamp(e.laser + dt*2.2, 0, 1);
          addAlert(dt*18);
        }else{
          e.laser = Math.max(0, e.laser - dt*1.5);
        }
        if(sees && e.laser>0.55 && dx<16 && dy2<90){
          hurtPlayer(1, 160, -320);
          setMessage("Drone: ‚ÄúBZZT.‚Äù Lili: ‚Äúisso foi pessoal!‚Äù");
        }
      }
      else if(e.kind==="saw"){
        e.t += dt;
        e.x = e.baseX + Math.sin(e.t*1.8)*e.range;
        if(aabb(p.x,p.y,p.w,p.h, e.x,e.y,e.w,e.h)){
          hurtPlayer(1, 320, -420);
          setMessage("Serra! Lili: ‚ÄúN√ÉO era pra ser decora√ß√£o!‚Äù");
        }
      }
      else if(e.kind==="chaser"){
        e.ttl -= dt;
        const dx = (p.x - e.x);
        e.face = dx>=0 ? 1 : -1;
        const speed2 = 160 + (State.alert>60?60:0);
        e.vx = clamp(dx, -1, 1) * speed2;
        e.vy = Math.min(MAX_FALL, e.vy + GRAV*dt);
        if(e.onGround){
          const aheadX = e.face>0 ? e.x+e.w+2 : e.x-2;
          const t1 = tileAt(L, aheadX, e.y+e.h-2);
          const t2 = tileAt(L, aheadX, e.y+6);
          if(solid(t1) || solid(t2)) e.vy = -460;
        }
        moveAndCollide(L, e, dt);
        if(aabb(p.x,p.y,p.w,p.h, e.x,e.y,e.w,e.h)){
          hurtPlayer(2, 360, -520);
          setMessage("Perseguidor te alcan√ßou! Lili: ‚Äúvai morder? porque eu mordo tamb√©m!‚Äù");
        }
        if(e.ttl <= 0){
          e._dead = true;
          State.alertSpawned = false;
          State.alert = Math.max(0, State.alert-30);
          setMessage("O perseguidor desistiu. (Ele tamb√©m tem limites.)");
        }
      }
    }
    State.entities = State.entities.filter(e => !e._dead);

    // alert decay
    State.alert = Math.max(0, State.alert - State.alertDecay*dt);

    // fall
    if(p.y > L.h*TILE + 200) respawn();

    // exit zone
    if(aabb(p.x,p.y,p.w,p.h, L.exit.x, L.exit.y, L.exit.w, L.exit.h)){
      if(L.id===1){
        const anyOpened = State.doors.some(d=>d.open && (d.h>=TILE*2));
        if(!anyOpened){
          setMessage("Ainda n√£o! Abra o port√£o antes de fugir.");
        }else{
          setMessage("Fase conclu√≠da! Lili: ‚Äútchau, pris√£o!‚Äù");
          audio.beep(880,0.06,"square",0.06);
          audio.beep(990,0.06,"square",0.06);
          saveGame();
          nextLevel();
        }
      } else if(L.id===3){
        setMessage("Casa doce casa! üè°");
        audio.beep(880,0.06,"square",0.06);
        audio.beep(740,0.06,"square",0.06);
        nextLevel();
      } else {
        setMessage("Fase conclu√≠da! Lili continua correndo!");
        audio.beep(880,0.06,"square",0.06);
        saveGame();
        nextLevel();
      }
    }

    // objective pacing
    if(L.id===2 && p.objectiveStep<1 && p.x > 50*TILE){ p.objectiveStep = 1; setMessage(L.objectives[1]); saveGame(); }
    if(L.id===2 && p.objectiveStep<2 && p.x > 95*TILE){ p.objectiveStep = 2; setMessage(L.objectives[2]); saveGame(); }
    if(L.id===3 && p.objectiveStep<1 && p.x > 60*TILE){ p.objectiveStep = 1; setMessage(L.objectives[1]); saveGame(); }
    if(L.id===3 && p.objectiveStep<2 && p.x > 105*TILE){ p.objectiveStep = 2; setMessage(L.objectives[2]); saveGame(); }

    // particles
    updateParticles(dt);

    // camera
    const targetCamX = clamp(p.x - BASE_W*0.45, 0, L.w*TILE - BASE_W);
    const targetCamY = clamp(p.y - BASE_H*0.55, 0, L.h*TILE - BASE_H);
    State.camX = lerp(State.camX, targetCamX, 1 - Math.pow(0.0001, dt));
    State.camY = lerp(State.camY, targetCamY, 1 - Math.pow(0.0001, dt));
    State.shake = Math.max(0, State.shake - dt);
  }

  function render(){
    if(!State.level){
      ctx.fillStyle="#05070f"; ctx.fillRect(0,0,BASE_W,BASE_H);
      pixText("Al√¥ Lilinha", BASE_W/2, BASE_H/2-10, 22, "#e5e7eb", "center");
      pixText("Clique em Jogar", BASE_W/2, BASE_H/2+18, 14, "#94a3b8", "center");
      return;
    }

    const L = State.level;
    const shake = State.shake>0 ? (Math.sin(State.time*60)*6*State.shake) : 0;
    const camX = (State.camX + shake)|0;
    const camY = (State.camY + shake*0.6)|0;

    drawBackground(L.theme, camX);

    // visible tiles
    const x0 = Math.floor(camX / TILE) - 2;
    const y0 = Math.floor(camY / TILE) - 2;
    const x1 = x0 + Math.ceil(BASE_W / TILE) + 4;
    const y1 = y0 + Math.ceil(BASE_H / TILE) + 4;

    // soft "ground haze"
    ctx.save();
    ctx.globalAlpha = 0.18;
    const haze = ctx.createLinearGradient(0, BASE_H*0.55, 0, BASE_H);
    haze.addColorStop(0,"rgba(0,0,0,0)");
    haze.addColorStop(1,"rgba(0,0,0,0.35)");
    ctx.fillStyle = haze;
    ctx.fillRect(0, BASE_H*0.55, BASE_W, BASE_H);
    ctx.restore();

    // tiles
    for(let ty=y0; ty<=y1; ty++){
      for(let tx=x0; tx<=x1; tx++){
        const id = L.get(tx,ty);
        if(id===T.EMPTY) continue;
        const sx = tx*TILE - camX;
        const sy = ty*TILE - camY;
        drawTile(id, sx, sy, L.theme, tx, ty);
      }
    }

    // exit marker
    ctx.save();
    ctx.globalAlpha = 0.10;
    pixRect(L.exit.x - camX, L.exit.y - camY, L.exit.w, L.exit.h, "#22c55e");
    ctx.restore();

    // pickups
    for(const pk of State.pickups){
      if(pk.taken) continue;
      drawPickup(pk, pk.x - camX, pk.y - camY);
    }

    // doors
    for(const d of State.doors){
      drawDoor(d, d.x - camX, d.y - camY);
    }

    // entities
    for(const e of State.entities){
      const sx = e.x - camX;
      const sy = e.y - camY;
      if(e.kind==="guard") drawGuard(e, sx, sy);
      else if(e.kind==="drone") drawDrone(e, sx, sy);
      else if(e.kind==="saw") drawSaw(e, sx, sy);
      else if(e.kind==="chaser") drawChaser(e, sx, sy);
    }

    // particles (world-space)
    renderParticles(camX, camY);

    // player
    const p = State.player;
    const px = p.x - camX, py = p.y - camY;
    if(!(p.invuln>0 && (Math.floor(State.time*18)%2===0))){
      drawLili(p, px, py);
    }

    // post vibes
    vignette(0.52);

    // HUD
    drawHUD();
  }

  // UI buttons
  btnPlay.addEventListener("click", () => {
    audio.beep(660,0.05,"square",0.05);
    const s = loadGame();

    if(State.mode==="paused"){
      State.mode="playing";
      setMode("playing");
      btnContinue.style.display = "";
      btnPlay.textContent = "Jogar";
      menuSubtitle.textContent =
        "Lili, a cachorra caramelo mais esperta do bairro, est√° fugindo da pris√£o pra voltar pra casa. Pegue a chave, fuja do port√£o e n√£o deixe os guardas aumentarem o alerta ‚Äî porque quando o alarme toca, a bagun√ßa come√ßa.";
      return;
    }

    if(State.mode==="gameover" || State.mode==="win"){
      btnContinue.style.display = "";
      btnPlay.textContent = "Jogar";
      menuSubtitle.textContent =
        "Lili, a cachorra caramelo mais esperta do bairro, est√° fugindo da pris√£o pra voltar pra casa. Pegue a chave, fuja do port√£o e n√£o deixe os guardas aumentarem o alerta ‚Äî porque quando o alarme toca, a bagun√ßa come√ßa.";
      startLevel(0, null);
      State.mode="playing";
      setMode("playing");
      saveGame();
      return;
    }

    startLevel(0, null);
    State.mode="playing";
    setMode("playing");
    saveGame();
  });

  btnContinue.addEventListener("click", () => {
    audio.beep(660,0.05,"square",0.05);
    const s = loadGame();
    if(!s){ showHint("Sem progresso salvo."); return; }
    startLevel(s.levelIndex ?? 0, s);
    State.mode="playing";
    setMode("playing");
  });

  btnReset.addEventListener("click", () => {
    audio.beep(220,0.06,"square",0.05);
    clearSave();
    showHint("Progresso apagado.");
  });

  // keyboard helpers
  function togglePauseKey(){
    if(State.mode==="playing" || State.mode==="paused") togglePause();
  }

  // Init menu
  setMode("menu");
  (function initMenuText(){
    const s = loadGame();
    if(s){
      menuObjective.textContent = `Continuar da Fase ${ (s.levelIndex??0)+1 }`;
    }else{
      menuObjective.textContent = `Fase 1: Encontre a chave da cela, abra o port√£o e alcance a sa√≠da.`;
    }
  })();

  // loop
  let last = performance.now();
  function loop(now){
    const raw = (now - last) / 1000;
    last = now;
    const dt = clamp(raw, 0, 0.033);

    if(State.level && State.mode!=="paused" && State.mode!=="menu"){
      update(dt);
    }else{
      // keep subtle anim in menus
      State.time += dt;
      State.dt = dt;
      if(State.level){
        updateParticles(dt*0.15);
      }
    }

    render();
    clearPressed();
    requestAnimationFrame(loop);
  }

  // Start audio context on interaction
  canvas.addEventListener("pointerdown", () => { audio.beep(0,0,"square",0); });

  // Enter = play
  window.addEventListener("keydown", (e) => {
    if(e.key === "Enter" && State.mode==="menu") btnPlay.click();
  });

  // Prevent mobile scroll on canvas
  document.addEventListener("touchmove", (e)=> { if(e.target === canvas) e.preventDefault(); }, { passive:false });

  // Start with level loaded (for background)
  const s0 = loadGame();
  if(s0){
    startLevel(s0.levelIndex ?? 0, s0);
    State.mode = "menu";
    setMode("menu");
  }else{
    startLevel(0, null);
    State.mode = "menu";
    setMode("menu");
  }

  setTimeout(() => { showHint("Dica: perto de portas, aperte E", 1800); }, 800);

  requestAnimationFrame(loop);

})();
</script>
</body>
</html>
